<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0035)http://rain.ifmo.ru/~komarov/y2013/ -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" g_init="6860"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        
        <link rel="stylesheet" type="text/css" href="./ОС_files/style.css">
        <title>ОС</title>
    <style type="text/css"></style></head>
    <body>
<h1 id="формат-сдачи-заданий">Формат сдачи заданий</h1>
<ul>
<li>У каждого студента есть свой <code>git</code> или <code>hg</code> репозиторий, в котором будет вестись работа над домашними заданиями. Зарегистрировать репозиторий можно по ссылке <a href="http://goo.gl/forms/JOlo6v5qO2" class="uri">http://goo.gl/forms/JOlo6v5qO2</a>.</li>
<li>Задания сдаются коммитами в этот репозиторий. Формат каждого задания оговаривается отдельно в его формулировке.</li>
<li>Если вам кажется, что вы видите в формулировке задании какую-то неоднозначность или другую проблему, об этом желательно спросить.</li>
<li>Мы постараемся прикрутить (в тех заданиях, где это возможно) частично автоматизированную проверку.</li>
<li>Задание считается <em>принятым на проверку</em>, если оно было до дедлайна залито в репозиторий и прошло автоматическую проверку (если она уже допилена), или просто залито в репозиторий до дедлайна (если автоматическая проверка ещё не допилена). Стоит заметить, что задание вряд ли пройдёт автоматическую проверку при несоблюдении требований, описанных ниже.</li>
<li>Принятое на проверку задание нужно <em>защитить</em> на паре. Необходимое условие для защиты — понимание происходящего в написанном коде.</li>
<li>Если задание было принято на паре, но не проходит тесты, его необходимо исправить и после дозащитить.</li>
<li>В момент дедлайна состояние репозиториев фиксируется. На зафиксированном репозитории запускаются <em>все</em> тесты.</li>
<li>Тесты запускаются под <code>Ubuntu 14.04</code>. Рекомендуется к прочтению информация об особенностях линковки под убунтой: <a href="http://goo.gl/GcGpjc" class="uri">http://goo.gl/GcGpjc</a>. В дальнейшем код, не линкующийся под убунтой, проверяться не будет.</li>
<li>Текущие результаты доступны по ссылке <a href="http://goo.gl/JDGHZI" class="uri">http://goo.gl/JDGHZI</a>. Каждый лист (кроме легенды) содержит информацию о состоянии репозиториев на момент соответствующего дедлайна.</li>
</ul>
<h1 id="инструкция-по-действиям-на-защите-заданий">Инструкция по действиям на защите заданий</h1>
<ul>
<li>Во время сдачи задания <strong>X</strong> вы берёте коммит, отмеченный в таблице с результами как <em>зафиксированный</em> для этого задания, и создаёте от него новую ветку с названием <code>defenceXXYY</code> (название ветки будет отдельно оглашаться на сдаче).
<ul>
<li><code>git checkout -b defenceXXYY &lt;hash&gt;</code></li>
</ul></li>
<li>Оглашается небольшое задание, которое нужно сделать и показать во время сдачи.</li>
<li>Вы делаете это задание и подходите сдавать.</li>
<li>Не забудьте во время или после сдачи запушить эту ветку.
<ul>
<li><code>git push origin defenceXXYY</code></li>
</ul></li>
</ul>
<h1 id="требования-к-домашним-заданиям">Требования к домашним заданиям</h1>
<ul>
<li>Если не указано обратное, задания нужно писать на языке C.</li>
<li>Ошибки во время выполнения программы не должны игнорироваться.</li>
<li>В репозитории не должно быть бинарников: они должны получаться в результате запуска скриптов сборки.</li>
<li>Ожидается, что выполнение <code>make</code> в корне вашего репозитория приведёт к генерации всех требуемых бинарников.</li>
<li>В силе все пункты раздела <strong>Homeworks</strong> из <a href="http://oxij.org/activity/itmo/general/" class="uri">http://oxij.org/activity/itmo/general/</a>, кроме первых двух.</li>
<li><code>make</code> должен работать корректно:
<ul>
<li>Если файл с поменялся, то запуск <code>make</code> пересобирает зависящие от этого файла цели.</li>
<li>Если ни один файл не поменялся, то запуск <code>make</code> ничего не пересобирает.</li>
<li>При сборке, непосредственно, программ можно считать (а можно и не считать), что библиотека уже собрана.</li>
</ul></li>
</ul>
<h1 id="задание-первое">Задание первое</h1>
<p>В первом задании необходимо реализовать примитивный вариант утилиты <code>cat</code>, копирующий символы из stdin на stdout.</p>
<h2 id="первая-часть">Первая часть</h2>
<p>Требуется реализовать динамическую библиотеку, содержащую функции-хелперы <code>read_</code> и <code>write_</code>, делающие то же, что и <code>read</code> и <code>write</code>, но для буфера целиком (либо до EOF). Сигнатуры хелперов должны совпадать с сигнатурами оригинальных функций.</p>
<h3 id="файлы-в-репозитории">Файлы в репозитории</h3>
<ul>
<li><code>/lib/helpers.h</code></li>
<li><code>/lib/helpers.c</code></li>
<li><code>/lib/Makefile</code></li>
</ul>
<h3 id="скриптом-сборки-генерируется">Скриптом сборки генерируется</h3>
<ul>
<li><code>/lib/libhelpers.so</code></li>
</ul>
<h3 id="hints">Hints</h3>
<ul>
<li><code>man 2 read</code></li>
<li><code>man 2 write</code></li>
</ul>
<h2 id="вторая-часть">Вторая часть</h2>
<p>Используя функции-хелперы из первой части, реализовать утилиту <code>cat</code>. В качестве аргумента <code>fd</code> хелперам <code>read_</code> и <code>write_</code> необходимо передавать <code>STDIN_FILENO</code> и <code>STDOUT_FILENO</code> соответственно.</p>
<h3 id="файлы-в-репозитории-1">Файлы в репозитории</h3>
<ul>
<li><code>/cat/cat.c</code></li>
<li><code>/cat/Makefile</code></li>
</ul>
<h3 id="скриптом-сборки-генерируется-1">Скриптом сборки генерируется</h3>
<ul>
<li><code>/cat/cat</code></li>
</ul>
<h3 id="пример-работы">Пример работы</h3>
<ul>
<li><code>./cat &lt; cat.c &gt; cat2.c &amp;&amp; diff cat.c cat2.c &amp;&amp; echo OK</code></li>
</ul>
<h2 id="дедлайн">Дедлайн</h2>
<ul>
<li><code>11 марта, 06:00 (GMT+3)</code></li>
</ul>
<h1 id="задание-второе">Задание второе</h1>
<p>Требуется реализовать утилиту <code>revwords</code>, читающую слова из stdin и выводящую в stdout эти же слова развёрнутыми. Гарантируется, что каждое слово имеет длину не более 4096 байт.</p>
<h2 id="первая-часть-1">Первая часть</h2>
<p>Добавить в библиотеку функцию <code>read_until</code>, имеющую следующую сигнатуру:</p>
<pre><code>ssize_t read_until(int fd, void * buf, size_t count, char delimiter);</code></pre>
<p>Функция имеет ту же семантику, что и <code>read_</code> из первого задания, с одним отличием: она прекращает считывание из <code>fd</code> не только при заполнении буфера, но и при наличии символа <code>delimiter</code> в уже заполенной части буфера.</p>
<h3 id="файлы-в-репозитории-2">Файлы в репозитории</h3>
<ul>
<li><code>/lib/helpers.h</code></li>
<li><code>/lib/helpers.c</code></li>
<li><code>/lib/Makefile</code></li>
</ul>
<h3 id="скриптом-сборки-генерируется-2">Скриптом сборки генерируется</h3>
<ul>
<li><code>/lib/libhelpers.so</code></li>
</ul>
<h2 id="вторая-часть-1">Вторая часть</h2>
<p>Используя функции из библиотеки, реализовать требуемую утилиту. Если в буфере есть слово, которое может быть выведено на stdout, утилита не должна ожидать данных из stdin.</p>
<p>Слова отделяются друг от друга пробелом. Все прочие символы, в том числе <code>\n</code> и <code>\t</code>, считаются буквой.</p>
<h3 id="файлы-в-репозитории-3">Файлы в репозитории</h3>
<ul>
<li><code>/revwords/revwords.c</code></li>
<li><code>/revwords/Makefile</code></li>
</ul>
<h3 id="скриптом-сборки-генерируется-3">Скриптом сборки генерируется</h3>
<ul>
<li><code>/revwords/revwords</code></li>
</ul>
<h3 id="пример-использования">Пример использования</h3>
<p>Команда <code>(echo -ne "abc def\ngh" ; sleep 3; echo -ne " qwer") | ./revwords</code> должна вести себя следующим образом: вывести <code>cba␣</code>, три секунды ничего не делать, вывести <code>hg\nfed␣rewq</code>, где знаком <code>␣</code> обозначается пробел. <!-- Бесит pandoc, сжирающий пробелы в конце verbatim-блока --></p>
<h2 id="дедлайн-1">Дедлайн</h2>
<ul>
<li><code>18 марта, 06:00 (GMT+3)</code></li>
</ul>
<h1 id="задание-третье">Задание третье</h1>
<p>Реализовать утилиту <code>filter</code>, читающую строки из stdin, передающую эти строки как последний аргумент команде, указанной в <code>argv</code>, и выводящую только те из них, на которых команда завершилась с нулевым кодом возврата.</p>
<h2 id="часть-первая">Часть первая</h2>
<p>Добавить в библиотеку следующую функцию:</p>
<p><code>int spawn(const char * file, char * const argv [])</code></p>
<p>Функция должна запускать исполняемый файл <code>file</code>, выбираемый в соответствии с переменной окружения <a href="http://en.wikipedia.org/wiki/PATH_(variable)"><code>PATH</code></a>, с аргументами, задаваемыми в <code>argv</code>, дожидаться её завершения и возвращать её код возврата.</p>
<p>Например, <del>если специально не предпринимать против этого мер,</del> следующий код</p>
<pre><code>char* args[] = {"ls", "/bin", NULL};
int res = spawn("ls", args);</code></pre>
<p>должен показывать содержимое директории <code>/bin</code> и возвращать <code>res = 0</code>.</p>
<h3 id="файлы-в-репозитории-4">Файлы в репозитории</h3>
<ul>
<li><code>/lib/helpers.h</code></li>
<li><code>/lib/helpers.c</code></li>
<li><code>/lib/Makefile</code></li>
</ul>
<h3 id="скриптом-сборки-генерируется-4">Скриптом сборки генерируется</h3>
<ul>
<li><code>/lib/libhelpers.so</code></li>
</ul>
<h3 id="hints-1">Hints</h3>
<ul>
<li><code>man 2 fork</code></li>
<li><code>man 3 exec</code></li>
<li><code>man 2 wait</code></li>
</ul>
<h3 id="запрещается-использовать">Запрещается использовать</h3>
<ul>
<li><code>man 3 system</code></li>
</ul>
<h2 id="часть-вторая">Часть вторая</h2>
<p>Используя библиотеку, реализовать требуемую утилиту.</p>
<p>Строки отделяются друг от друга <code>\n</code>.</p>
<h3 id="файлы-в-репозитории-5">Файлы в репозитории</h3>
<ul>
<li><code>/filter/filter.h</code></li>
<li><code>/filter/filter.c</code></li>
<li><code>/filter/Makefile</code></li>
</ul>
<h3 id="скриптом-сборки-генерируется-5">Скриптом сборки генерируется</h3>
<ul>
<li><code>/filter/filter</code></li>
</ul>
<h3 id="пример-использования-1">Пример использования</h3>
<ul>
<li>Вызов <code>echo -ne "/bin/sh\n/blablabla\n/bin/cat\n" | ./filter tar cf   /tmp/filter.tar</code> должен вывести <code>/bin/sh</code> и <code>/bin/cat</code>.</li>
</ul>
<h2 id="дедлайн-2">Дедлайн</h2>
<ul>
<li><code>25 марта, 06:00 (GMT+3)</code></li>
</ul>
<h1 id="задание-четвёртое">Задание четвёртое</h1>
<p>Требуется реализовать аналог буферизированного ввода-вывода из <code>stdio.h</code>, но без аналога типу <code>FILE</code> и с другим интерфесом (и вообще не очень похоже, но ведь со знакомыми ключевыми словами спокойнее).</p>
<h2 id="первая-часть-2">Первая часть</h2>
<p>Требуется реализовать динамическую библиотеку содержащую:</p>
<ul>
<li><code>struct buf_t {...}</code> — буфер с максимальным размером хранимых данных далее именуемым <code>capacity</code> и заполненный на число байт далее именуемое <code>size</code>.</li>
<li><code>struct buf_t *buf_new(size_t capacity)</code> — конструктор пустого буфера, возвращает <code>NULL</code> если не удалось сделать <code>malloc</code>,</li>
<li><code>void buf_free(struct buf_t *)</code> — деструктор.</li>
<li><code>size_t buf_capacity(buf_t *)</code> — возвращает максимальный возможный размер,</li>
<li><code>size_t buf_size(buf_t *)</code> — возвращает текущую заполненность,</li>
<li><p><code>ssize_t buf_fill(fd_t fd, buf_t *buf, size_t required)</code> — заполняет буфер <code>read</code>ами до тех пор пока его <code>size</code> не станет как минимум <code>required</code> байт (если может больше — читает больше) или не наступит EOF. Возвращает:</p>
<ul>
<li><code>-1</code> при ошибке, ошибка в <code>errno</code>,</li>
<li><code>текущий size</code> если не ошибка:
<ul>
<li><code>&gt;= required</code> если всё удалось,</li>
<li><code>&lt; required</code> если рановато наступил EOF.</li>
</ul></li>
</ul></li>
</ul>
<p>Если в буфере не хватает <code>capacity</code>, то поведение не определено.</p>
<p>Заметьте, что <code>buf_fill(fd, buf, 1)</code> <em>для пустого буфера</em> должно пытаться заполнить весь буфер, <code>buf_fill(fd, buf, 1)</code> <em>для буфера в котором есть хотя бы один байт</em> должно делать ровно ничего, а <code>buf_fill(fd, buf, buf_capacity(buf))</code> должно заполнять весь буфер, если это вообще возможно.</p>
<ul>
<li><p><code>ssize_t buf_flush(fd_t fd, buf_t *buf, size_t required)</code> — выписывает данные из буфера до тех пор, пока не будет записано как минимум <code>required</code> байт (больше — так больше) или буфер не опустеет. Возвращает:</p>
<ul>
<li><code>-1</code> при ошибке, ошибка в <code>errno</code>,</li>
<li><code>предыдущий size - текущий size</code> если не ошибка:
<ul>
<li><code>&gt;= required</code> если всё удалось,</li>
<li><code>&lt; required</code> если в буфере столько нету.</li>
</ul></li>
</ul></li>
</ul>
<p>Удачно записанные данные выбрасываются из буфера.</p>
<p>Заметьте, что <code>buf_flush(fd, buf, 1)</code> должно пытаться записать весь буфер, а <code>buf_flush(fd, buf, buf_size(buf))</code> должно записывать весь буфер если это вообще возможно.</p>
<p>Все функции имеют неопределённое поведение, когда <code>buf_t *</code> аргумент равен <code>NULL</code>.</p>
<p>При компиляции с <code>#define DEBUG</code> все неопределённые поведения должны вызывать завершение программы при помощи <code>abort</code>.</p>
<h3 id="файлы-в-репозитории-6">Файлы в репозитории</h3>
<ul>
<li><code>/lib/bufio.h</code></li>
<li><code>/lib/bufio.c</code></li>
<li><code>/lib/Makefile</code></li>
</ul>
<h3 id="скриптом-сборки-генерируется-6">Скриптом сборки генерируется</h3>
<ul>
<li><code>/lib/libbufio.so</code></li>
</ul>
<h3 id="hints-2">Hints</h3>
<ul>
<li><code>man 2 read</code></li>
<li><code>man 2 write</code></li>
</ul>
<h2 id="вторая-часть-2">Вторая часть</h2>
<p>Используя <code>libbufio</code> из первой части, реализовать утилиту <code>cat</code>.</p>
<p>Даже если при чтении из <code>stdin</code> происходит ошибка, <em>все</em> уже прочитанные данные должны быть записаны в <code>stdout</code>, если это вообще возможно.</p>
<p>Если программа не помещается в 20 строк, то вы делаете что-то серьёзно не так.</p>
<h3 id="файлы-в-репозитории-7">Файлы в репозитории</h3>
<ul>
<li><code>/bufcat/bufcat.c</code></li>
<li><code>/bufcat/Makefile</code></li>
</ul>
<h3 id="скриптом-сборки-генерируется-7">Скриптом сборки генерируется</h3>
<ul>
<li><code>/bufcat/bufcat</code></li>
</ul>
<h2 id="дедлайн-3">Дедлайн</h2>
<ul>
<li><del><code>1 апреля, 06:00 (GMT+3)</code> (и это не шутка)</del></li>
<li>Какой-то шутник уронил рейн. <code>3 апреля, 06:00 (GMT+3)</code></li>
</ul>
<h1 id="задание-пятое">Задание пятое</h1>
<p>Требуется реализовать механизм, аналогичный <code>|</code> в терминале: запустить первую программу, передать её стандартный вывод на вход второй, стандартный вывод второй – на стандартный ввод третьей, … стандартный вывод <code>n-1</code>-й на стандартный ввод <code>n</code>-й, стандартный вывод <code>n</code>-й оставить без изменений.</p>
<h2 id="первая-часть-3">Первая часть</h2>
<p>Добавить в библиотеку (<code>libhelpers</code>) следующее:</p>
<ul>
<li><p><code>struct execargs_t {...}</code> – информация о том, какую программу с какими аргументами нужно запустить.</p></li>
<li><p>Какой-нибудь, на ваш выбор, способ конструирования <code>execargs_t</code>.</p></li>
<li><p><code>int exec(execargs_t* args)</code> – запустить указанную в <code>args</code> программу. Вернуть отрицательное число, если что-то пошло не так. Запуск производить аналогично запуску <code>spawn</code> из третьего задания: с учётом переменной окружения <code>PATH</code>.</p></li>
<li><p><code>int runpiped(execargs_t** programs, size_t n)</code> — запустить <code>n</code> программ, указанные в первых <code>n</code> элементах массива <code>programs</code>, связав стандартный вывод <code>programs[0]</code> со стандартным входом <code>programs[1]</code>, …, стандартный вывод <code>programs[n-2]</code> со стандартным вводом <code>programs[n-1]</code> и дождаться <em>завершения работы</em> этой цепочки. Соединение стандартного вывода одной программы со стандартным вводом другой осуществляется с помощью пайпа. Завершение работы может произойти по следующим причинам:</p>
<ul>
<li>прилетел SIGINT (например, пользователь нажал Ctrl+C)</li>
<li>один из запущенных процессов завершил работу</li>
<li>один из запущенных процессов закрыл пайп</li>
</ul></li>
</ul>
<p>Если что-то из этого произошло, нужно завершать всю цепочку процессов и вернуть 0. В случае ошибки, вернуть -1.</p>
<h3 id="файлы-в-репозитории-8">Файлы в репозитории</h3>
<ul>
<li><code>/lib/libhelpers.h</code></li>
<li><code>/lib/libhelpers.c</code></li>
<li><code>/lib/Makefile</code></li>
</ul>
<h3 id="скриптом-сборки-генерируется-8">Скриптом сборки генерируется</h3>
<ul>
<li><code>/lib/libhelpers.so</code></li>
</ul>
<h3 id="hints-3">Hints</h3>
<ul>
<li><code>man 2 pipe</code></li>
<li><code>man 3 dup</code>, <code>man 3 dup2</code></li>
<li><code>man 3 execlp</code></li>
<li><code>man 3 sigaction</code>, <code>man 2 kill</code>, <code>man 7 signal</code></li>
</ul>
<h2 id="вторая-часть-3">Вторая часть</h2>
<p>Используя <code>libbufio</code> из первой части, реализовать утилиту <code>simplesh</code>.</p>
<p>Утилита должна вести себя следующим образом:</p>
<ol style="list-style-type: decimal">
<li>Выводит приглашение командной строки <code>$</code>.</li>
<li>Считывает строку со стандартного ввода.</li>
<li>Разбивает её по символу <code>|</code>. Получатся программы с аргументами, которые нужно будет запустить.</li>
<li>Полученные после разбивки по <code>|</code> строки разбивает по пробелу (или нескольким). Получается программа, которую нужно запустить, и аргументы к ней (как следствие, нельзя дать программе аргумент, содержащий пробел или <code>|</code>)/.</li>
<li>Используя <code>runpiped</code> запускает эту цепочку процессов.</li>
<li>Ждёт завершения, повторяет.</li>
</ol>
<p>Ожидается, что пользователь будет работать с этой программой также, как с привычным эмулятором терминала. В частности, нажатие Ctrl+C убивает запущенную цепочку процессов, но не убивает сам <code>simplesh</code>. Ctrl+D вместо задания строки должен приводить к выходу из <code>simplesh</code>.</p>
<h3 id="файлы-в-репозитории-9">Файлы в репозитории</h3>
<ul>
<li><code>/simplesh/simplesh.c</code></li>
<li><code>/simplesh/Makefile</code></li>
</ul>
<h3 id="скриптом-сборки-генерируется-9">Скриптом сборки генерируется</h3>
<ul>
<li><code>/simplesh/simplesh</code></li>
</ul>
<h3 id="пример-работы-1">Пример работы</h3>
<pre><code>$ls
&lt;показано содержимое директории&gt;
$find /home | grep \.c | head
&lt;показаны какие-то 10 файлов, заканчивающихся на .c&gt;
$find /home | head | cat
&lt;показаны какие-то 10 файлов&gt;
$cat /dev/urandom | grep 12345678
&lt;работает. после нажатия Ctrl+C останавливается&gt;
$&lt;Ctrl+D приводит к завершению работы&gt;</code></pre>
<h2 id="дедлайн-4">Дедлайн</h2>
<ul>
<li><code>29 мая, 06:00 (GMT+3)</code></li>
</ul>
<h1 id="задание-шестое">Задание шестое</h1>
<p>Требуется поработать с различными вариантами обработки множества запросов.</p>
<h2 id="часть-первая-1">Часть первая</h2>
<p>Требуется написать TCP-сервер, который отправляет всем своим клиентам заданный файл, fork(2)аясь на каждый запрос.</p>
<h3 id="формулировка">Формулировка</h3>
<ul>
<li>Программа аргументами принимает:
<ul>
<li>порт, на котором будет слушать сервер;</li>
<li>название файла, который будет отправляться.</li>
</ul></li>
<li>Сервер создаёт сокет из указанного порта используя getaddrinfo(3) для <code>localhost</code>.</li>
<li>Сервер ждёт подключений на этом порту.</li>
<li>Как только кто-то accept(2)нулся, сервер fork(2)ется, родитель продолжает accept(2)ать новых клиентов, а ребёнок отправляет содержимое заданного файла клиенту.</li>
</ul>
<hr>
<ul>
<li>Следует использовать ваш bufio.</li>
<li>Несколько клиентов могут получать файл независимо друг от друга.</li>
</ul>
<h3 id="файлы-в-репозитории-10">Файлы в репозитории</h3>
<ul>
<li><code>/filesender/filesender.c</code></li>
<li><code>/filesender/Makefile</code></li>
</ul>
<h3 id="скриптом-сборки-генерируется-10">Скриптом сборки генерируется</h3>
<ul>
<li><code>/filesender/filesender</code></li>
</ul>
<h3 id="hints-4">Hints</h3>
<ul>
<li><code>man 2 fork</code></li>
<li><code>man 2 {socket,bind,listen,accept}</code></li>
<li><code>man 3 getaddrinfo</code></li>
<li><code>man 7 ip</code></li>
<li><code>man 2 open</code></li>
<li><code>man 1 nc</code></li>
<li><code>man 1 socat</code></li>
<li>Не забывайте закрывать лишние файловые дескрипторы!</li>
</ul>
<h3 id="ещё-больше-подсказок">Ещё больше подсказок</h3>
<p>Пример работы с TCP без getaddrinfo. Сервер, который ждёт подключения на порту TCPv4 номер 1234 и немножко разговаривает с тем, кто подключился.</p>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
int main()
{
  int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (sock == -1)
    perror("socket");
  printf("sock = %d\n", sock);
  int one = 1;
  if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;one, sizeof(int)) == -1)
    perror("setsockopt");
  struct sockaddr_in addr = {
    .sin_family = AF_INET,
    .sin_port = htons(1234),
    .sin_addr = {.s_addr = INADDR_ANY}};
  if (bind(sock, (struct sockaddr*)&amp;addr, sizeof(addr)) == -1)
    perror("bind");
  if (listen(sock, 1) == -1)
    perror("listen");
  struct sockaddr_in client;
  socklen_t sz = sizeof(client);
  int fd = accept(sock, (struct sockaddr*)&amp;client, &amp;sz);
  if (fd == -1)
    perror("accept");
  printf("accept = %d\n", fd);
  printf("from %s:%d\n", inet_ntoa(client.sin_addr), ntohs(client.sin_port));
  char hello[] = "hello\n";
  if (write(fd, hello, sizeof(hello)) == -1)
    perror("write");
  char reply[100];
  ssize_t r = read(fd, reply, sizeof(reply));
  if (r == -1)
    perror("read");
  reply[r] = 0;
  printf("reply: %s\n", reply);
  return 0;
}</code></pre>
<h3 id="пример-работы-2">Пример работы</h3>
<pre><code>|-------------------------------+----------------------------------|
| $ cat hello.txt               |                                  |
| Hello, world!                 |                                  |
| $ ./filesender 1234 hello.txt |                                  |
|                               | $ nc localhost 1234              |
|                               | Hello, world!                    |
|                               | $ socat STDIO TCP:localhost:1234 |
|                               | Hello, world!                    |
|-------------------------------+----------------------------------|</code></pre>
<pre><code>|------------------------------------------------------+-------------------------------------------------+----------------------------------|
| $ dd if=/dev/zero of=zeros.bin count=1000000         |                                                 |                                  |
| 1000000+0 records in                                 |                                                 |                                  |
| 1000000+0 records out                                |                                                 |                                  |
| 512000000 bytes (512 MB) copied, 1.23916 s, 413 MB/s |                                                 |                                  |
| $ md5sum zeros.bin                                   |                                                 |                                  |
| 7583b57452ccb83f9d313ab76e3629b8  zeros.bin          |                                                 |                                  |
| $ ./filesender 1235 zeros.bin                        |                                                 |                                  |
|                                                      | $ nc localhost 1235 | (sleep 100; cat) | md5sum |                                  |
|                                                      | 7583b57452ccb83f9d313ab76e3629b8                |                                  |
|                                                      | # через полторы минуты                          | $ nc localhost 1235 | md5sum     |
|                                                      |                                                 | 7583b57452ccb83f9d313ab76e3629b8 |
|                                                      |                                                 | # быстрее                        |
|------------------------------------------------------+-------------------------------------------------+----------------------------------|</code></pre>
<h2 id="часть-вторая-1">Часть вторая</h2>
<p>Аналогично первой части, но теперь вместо файла серверу указывается второй порт на котором надо слушать, а данные передаются между парами клиентов, подключённых к двум различным портам, в обе стороны.</p>
<h3 id="формулировка-1">Формулировка</h3>
<ul>
<li>Программа принимает два аргумента с номерами портов.</li>
<li>Сервер ждёт подключения на первом порту.</li>
<li>Как только кто-то accept(2)нулся, сервер начинает ждать подключения на втором порту.</li>
<li>Как только кто-то accept(2)нулся на втором порту, сервер fork(2)ется дважды, родитель продолжает accept(2)ать, а дети начинают перенаправлять данные между двумя сокетами: один — в одну сторону, другой — в другую).</li>
</ul>
<hr>
<ul>
<li>Следует использовать ваш bufio.</li>
<li>Несколько пар клиентов могут работать независимо друг от друга.</li>
</ul>
<h3 id="файлы-в-репозитории-11">Файлы в репозитории</h3>
<ul>
<li><code>/bipiper/forking.c</code></li>
<li><code>/bipiper/Makefile</code></li>
</ul>
<h3 id="скриптом-сборки-генерируется-11">Скриптом сборки генерируется</h3>
<ul>
<li><code>/bipiper/forking</code></li>
</ul>
<h3 id="hints-5">Hints</h3>
<ul>
<li>Аналогично первой части.</li>
</ul>
<h3 id="пример-работы-3">Пример работы</h3>
<pre><code>|-----------------------+---------------------+----------------------------------|
| $ ./forking 1234 4321 |                     |                                  |
|                       | $ nc localhost 1234 | $ socat STDIO TCP:localhost:1234 |
|                       |                     |                                  |
|                       | &lt; Hi!               |                                  |
|                       |                     | &gt; Hi!                            |
|                       |                     | &lt; Hi. How are you?               |
|                       | &gt; Hi. How are you?  |                                  |
|-----------------------+---------------------+----------------------------------|</code></pre>
<h2 id="дедлайн-первых-двух-частей">Дедлайн первых двух частей</h2>
<ul>
<li><code>3 июня, 06:00 (GMT+3)</code></li>
</ul>
<h2 id="часть-третья">Часть третья</h2>
<p>Аналогично второй части, но без fork, а с poll.</p>
<p>Снаружи сервер выглядит абсолютно эквивалентно серверу из второй части, но внутри он никогда не fork(2)ается, а всё обрабатывается в одном цикле через один единственный poll.</p>
<p>Дальше тут строго предполагается, что вы действительно слушали лекцию и/или прочли <code>man 2 poll</code>. Если ещё нет, то сейчас самое время. Вот прямо сейчас. Я предупредил.</p>
<h3 id="формулировка-2">Формулировка</h3>
<ul>
<li>Программа принимает два аргумента с номерами портов.</li>
<li>Сервер делает poll(2).</li>
<li>После появления соединений на оба порта, сервер выделяет пару буферов и добавляет полученные два клиентских файловых дескриптора в массив для poll.</li>
<li>Обрабатывает пары уже существующих клиентов.</li>
</ul>
<hr>
<ul>
<li>Следует использовать ваш bufio.</li>
<li>До 127 пар клиентов могут работать независимо друг от друга. Если их становится 127, то сервер просто больше не делает acceptов до освобождения ресурсов.</li>
<li>При ошибке или лаге между какой-то парой клиентов остальные пары клиентов не должны страдать.</li>
</ul>
<p>Каждая пара клиентов для сервера выглядит так:</p>
<pre><code>fd1 =&gt; | buffer1 | =&gt; fd2
fd2 =&gt; | buffer2 | =&gt; fd1</code></pre>
<p>и этими bufferами между этими fd вы в этом задании делаете аналог pipe(2) ("с его обратной стороны") опрашивая стейты этих fd через poll(2).</p>
<ul>
<li>Заметьте, что если, например, buffer1 пуст, то про fd2 нельзя спрашивать у poll разрешения на POLLOUT (а не то будете жрать 100% CPU), что в ядре было бы эквивалентно приостановке процесса fd2.</li>
<li>Аналогично, если buffer1 полон, то про fd1 нельзя спрашивать у poll разрешения на POLLIN, что в ядре было бы эквивалентно приостановке процесса fd1.</li>
</ul>
<p>Внутри у вашего сервера должно быть множество структур вида "пара файловых дескрипторов и пара буферов" для двунаправленных пайпов для максимум <code>127</code> клиентов, которые он poll(2)ит по мере надобности, используя один фиксированный массив <code>pollfd[256]</code> и один массив пар буферов <code>buffs[127]</code>.</p>
<p>Первые два файловых дескриптора в первом из массивов — accept сокеты, остальные — пары дескрипторов из двунаправленных пайпов. Во втором массиве только пары буферов.</p>
<p>Картинкой:</p>
<pre><code>|-------------+-------------+---------|
| pollfd[256] | buffs[127]  |         |
|-------------+-------------+---------|
| acceptfd1   |             |         |
|             |             |         |
| acceptfd2   |             |         |
|             |             |         |
| fd1         | { buffer1   | x x     |
|             |             |  x  127 |
| fd2         |   buffer2 } | x x     |
|-------------+-------------+---------|</code></pre>
<p>У сервера два состояния:</p>
<ul>
<li>делаем accept(2) на первом порту,</li>
<li>делаем accept(2) на втором порту,</li>
</ul>
<p>в каждом из которых он спрашивает POLLIN только у соответствующего нужному порту accept сокету и одновременно опрашивает нужных ему для работы живых клиентов.</p>
<p>Когда какой-то из пайпов завершается, нужно свопать эти элементы массивов с последними занятыми элементами, чтобы не спрашивать poll больше, чем надо.</p>
<p>Картинкой для <code>pollfd</code>:</p>
<pre><code>| acceptfd1 | acceptfd2 | fd1₁ | fd2₁ | fd1₂ | fd2₂ | ... занятые ... | fd1ₙ | fd2ₙ | fd1_empty | fd2_empty | ... свободные
                        {                            2n штук                       }</code></pre>
<p>Вторая пара закрылась:</p>
<pre><code>| acceptfd1 | acceptfd2 | fd1₁ | fd2₁ | fd1ₙ | fd2ₙ | ... занятые ... | fd1₂ | fd2₂ | fd1_empty | fd2_empty | ... свободные
                        {                   2n - 1 штук              }</code></pre>
<p>И аналогично для <code>buffs</code>.</p>
<p>Между клиентами нужно делать прямо настоящие пайпы, для этого вам иногда придётся закрывать файловые дескрипторы только в одну сторону, что делается shutdown(2).</p>
<h3 id="файлы-в-репозитории-12">Файлы в репозитории</h3>
<ul>
<li><code>/bipiper/polling.c</code></li>
<li><code>/bipiper/Makefile</code></li>
</ul>
<h3 id="скриптом-сборки-генерируется-12">Скриптом сборки генерируется</h3>
<ul>
<li><code>/bipiper/polling</code></li>
</ul>
<h3 id="hints-6">Hints</h3>
<ul>
<li>Аналогично второй части.</li>
<li><code>man 2 poll</code> обратите внимание на <code>ERRORS</code>. poll может прерваться с <code>EINTR</code> и это не ошибка.</li>
<li><code>man 2 shutdown</code></li>
</ul>
<h3 id="пример-работы-4">Пример работы</h3>
<ul>
<li>Аналогично второй части.</li>
</ul>
<h2 id="дедлайн-для-третьей-части">Дедлайн для третьей части</h2>
<ul>
<li><code>5 июня, 06:00 (GMT+3)</code></li>
</ul>
    

<iframe src="./ОС_files/index.html" style="display: none;"></iframe></body><div></div><div></div></html>